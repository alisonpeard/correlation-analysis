acf(ts.d[,"LoS"])
pacf(ts.d[,indicator])
pacf(ts.d[,"LoS"])
data(DriverDeaths)
library(zoo)
data(DriverDeaths)
install.packages("glarms")
install.packages("glarma")
library(glarms)
library(glarma)
data(DriverDeaths)
library(glarma)
library(zoo)
data(DriverDeaths)
X <- as.matrix(DriverDeaths[, 2:5])
X
head(X)
Population <- DriverDeaths[, "Population"]
### Offset included
glarmamod <- glarma(y, X, offset = log(Population/100000),
phiLags = c(12),
thetaLags = c(1),
type = "Poi", method = "FS",
residuals = "Pearson", maxit = 100, grad = 1e-6)
y <- DriverDeaths[, "Deaths"]
X <- as.matrix(DriverDeaths[, 2:5])
Population <- DriverDeaths[, "Population"]
### Offset included
glarmamod <- glarma(y, X, offset = log(Population/100000),
phiLags = c(12),
thetaLags = c(1),
type = "Poi", method = "FS",
residuals = "Pearson", maxit = 100, grad = 1e-6)
summary(glarmamod)
print(summary(glarmamod))
XT1 <- matrix(X[72,], nrow = 1)
offsetT1 <- log(Population/100000)[72]
mu <- forecast(glarmamod, 1, XT1, offsetT1)$mu
print(mu)
### Save some values
allX <- X
allFits <- fitted(glarmamod)
ally <- y
par(mfrow = c(1,1))
forecasts <- ts(forecasts[63:72], start = c(1985, 10), deltat = 1/12)
### Look at a succession of forecasts
### Using actual values in forecasts
forecasts <- numeric(72)
for (i in (62:71)){
y <- DriverDeaths[1:i, "Deaths"]
X <- as.matrix(DriverDeaths[1:i, 2:5])
Population <- DriverDeaths[1:i, "Population"]
## Offset included
glarmamod <- glarma(y, X, offset = log(Population/100000),
phiLags = c(12),
thetaLags = c(1),
type = "Poi", method = "FS",
residuals = "Pearson", maxit = 100, grad = 1e-6)
XT1 <- matrix(allX[i + 1, ], nrow = 1)
offsetT1 <- log(DriverDeaths$Population[i + 1]/100000)
mu <- forecast(glarmamod, 1, XT1, offsetT1)$mu
if (i == 62){
forecasts[1:62] <- fitted(glarmamod)
}
forecasts[i+1] <- mu
}
par(mfrow = c(1,1))
forecasts <- ts(forecasts[63:72], start = c(1985, 10), deltat = 1/12)
fitted <- ts(allFits, start = c(1980, 8), deltat = 1/12)
obs <- ts(DriverDeaths$Deaths, start = c(1980, 8), deltat = 1/12)
plot(obs, ylab = "Driver Deaths", lty = 2,
main = "Single Vehicle Nighttime Driver Deaths in Utah")
points(obs)
lines(fitted, lwd = 2)
lines(forecasts, col = "red")
par(xpd = NA)
graph.param <-
legend("top",
legend = c("observations",expression(estimated~mu[t]),
expression(predicted~mu[t])),
ncol = 3,
cex = 0.7,
bty = "n", plot = FALSE)
legend(graph.param$rect$left,
graph.param$rect$top + graph.param$rect$h,
legend = c("observations", expression(estimated~mu[t]),
expression(predicted~mu[t])),
col = c("black","black","red"),
lwd = c(1,2,1), lty = c(2,1,1),
pch = c(1, NA_integer_, NA_integer_),
ncol = 3,
cex = 0.7,
bty = "n",
text.font = 4)
par(xpd = FALSE)
### Generate a sample of Y values 2 steps ahead and examine the distribution
data(DriverDeaths)
y <- DriverDeaths[, "Deaths"]
X <- as.matrix(DriverDeaths[, 2:5])
Population <- DriverDeaths[, "Population"]
glarmamod <- glarma(y[1:70], X[1:70, ],
offset = log(Population/100000)[1:70],
phiLags = c(12),
thetaLags = c(1),
type = "Poi", method = "FS",
residuals = "Pearson", maxit = 100, grad = 1e-6)
nObs <- NROW(X)
XT1 <- as.matrix(X[(nObs - n.ahead + 1):nObs, ])
n.ahead <- 2
XT1 <- as.matrix(X[(nObs - n.ahead + 1):nObs, ])
offsetT1 <- log(Population/100000)[(nObs - n.ahead + 1):nObs]
nSims <- 500
forecastY <- matrix(ncol = n.ahead, nrow = nSims)
forecastMu <- matrix(ncol = n.ahead, nrow = nSims)
XT1 <- as.matrix(X[(nObs - n.ahead + 1):nObs, ])
offsetT1 <- log(Population/100000)[(nObs - n.ahead + 1):nObs]
nSims <- 500
forecastY <- matrix(ncol = n.ahead, nrow = nSims)
forecastMu <- matrix(ncol = n.ahead, nrow = nSims)
### Generate sample predicted values
for(i in 1:nSims){
temp <-  forecast(glarmamod, n.ahead, XT1, offsetT1)
forecastY[i, ] <- temp$Y
forecastMu[i, ] <- temp$mu
}
### Examine distribution of sample of Y values n.ahead
table(forecastY[, 2])
par(mfrow = c(2,1))
barplot(table(forecastY[, 2]),
main = "Barplot of Sample Y Values 2 Steps Ahead")
hist(forecastY[, 2], xlab = "Sample Y values",
breaks=seq(0,max(forecastY[, 2])),
main = "Histogram of Sample Y Values 2 Steps Ahead\nwith 0.025 and 0.975 Quantiles")
abline(v = quantile(forecastY[, 2], c(0.025, 0.975)), col = "red")
par(mfrow=c(1, 1))
plot(decompose(x))
decompose(ts[,indicator])$seasonal
glarma
ts
ts[,"LoS"]
as.numeric(ts[,"LoS"])
X <- ts[,indicator]
rep(1, 2)
rep(1, length(y))
cbind(rep(1, length(y)), X)
length(X)
dim(X)
length(y)
cbind(rep(1, length(X)), X)
cbind(intersect=rep(1, length(X)), X)
X <- ts[,indicator]
X <- cbind(intersect=rep(1, length(X)), X)
# ACDF and PACFs
par(mfrow=c(2,2))
acf(ts.d[,indicator])
acf(ts.d[,"LoS"])
pacf(ts.d[,indicator])
pacf(ts.d[,"LoS"])
binomial.mod <- glarma(y, X,
phiLags = c(1),
thetaLags = c(8),
type = "Poi", method = "FS",
residuals = "Pearson", maxit = 100, grad = 1e-6)
length(y)
length(as.numeric(y))
y
X
length(ts[,"LoS"])
y <- ts.d[,"LoS"]
X <- ts.d[,indicator]
X <- cbind(intersect=rep(1, length(X)), X)
length(y)
length(X)
dim(as.numeric(X))
X
as.numeric(X)
as.matrix(X)
dim(as.matrix(X))
X <- ts.d[,indicator]
X <- as.matrix(cbind(intersect=rep(1, length(X)), X))
length(X)
dim(X)
binomial.mod <- glarma(y, X,
phiLags = c(1),
thetaLags = c(8),
type = "Poi", method = "FS",
residuals = "Pearson", maxit = 100, grad = 1e-6)
length(ts[,"LoS"])
y <- ts[,"LoS"]
X <- ts.d[,indicator]
X <- as.matrix(cbind(intersect=rep(1, length(X)), X))
binomial.mod <- glarma(y, X,
phiLags = c(1),
thetaLags = c(8),
type = "Poi", method = "FS",
residuals = "Pearson", maxit = 100, grad = 1e-6)
binomial.mod <- glarma(y, X,
phiLags = c(12),
thetaLags = c(12),
type = "Poi", method = "FS",
residuals = "Pearson", maxit = 100, grad = 1e-6)
summary(glarmamod)
binomial.mod <- glarma(y, X,
phiLags = c(12),
thetaLags = c(12),
type = "Poi", method = "FS",
residuals = "Pearson", maxit = 100, grad = 1e-6)
as.matrix(y)
clear
as.matrix
as.vector
y <- as.vector(ts[,"LoS"])
X <- ts.d[,indicator]
X <- as.matrix(cbind(intersect=rep(1, length(X)), X))
binomial.mod <- glarma(y, X,
phiLags = c(12),
thetaLags = c(12),
type = "Poi", method = "FS",
residuals = "Pearson", maxit = 100, grad = 1e-6)
X
ts[,c("intersect", "X")]
ts[,c("intersect", indicator)]
X <- ts.d[,indicator]
X <- cbind(intersect=rep(1, length(X)), X)
X
X[,indicator]
X[,2:3]
X[,1:2]
X[,2:2]
head(X[,2:2])
as.numeric(X)
as.numeric(ts.d[,indicator])
y <- as.vector(ts[,"LoS"])
X <- as.numeric(ts.d[,indicator])
X <- cbind(intersect=rep(1, length(X)), X)
head(X)
binomial.mod <- glarma(y, X,
phiLags = c(12),
thetaLags = c(12),
type = "Poi", method = "FS",
residuals = "Pearson", maxit = 100, grad = 1e-6)
y <- DriverDeaths[, "Deaths"]
X <- as.matrix(DriverDeaths[, 2:5])
head(y)
head(X)
head(DriverDeaths)
head(y)
y
y <- as.vector(ts[,"LoS"])
y
X
X <- as.numeric(ts.d[,indicator])
X <- cbind(intersect=rep(1, length(X)), X)
X
X <- as.numeric(ts.d[,indicator])
X <- cbind(intersect=rep(1, length(X)), variable=X)
head(X)
binomial.mod <- glarma(y, X,
phiLags = c(12),
thetaLags = c(12),
type = "Poi", method = "FS",
residuals = "Pearson", maxit = 100, grad = 1e-6)
X$variable
X[,'variable']
head(y)
y <- DriverDeaths[, "Deaths"]
X <- as.matrix(DriverDeaths[, 2:5])
y.1 <- as.vector(ts[,"LoS"])
X.1 <- as.numeric(ts.d[,indicator])
X.1 <- cbind(intersect=rep(1, length(X)), variable=X)
X.1 <- as.numeric(ts.d[,indicator])
X.1 <- cbind(intersect=rep(1, length(X.1)), variable=X.1)
y.1 <- as.numeric(ts[,"LoS"])
y.1 <- as.integer(ts[,"LoS"])
binomial.mod <- glarma(y, X,
phiLags = c(12),
thetaLags = c(12),
type = "Poi", method = "FS",
residuals = "Pearson", maxit = 100, grad = 1e-6)
y <- DriverDeaths[, "Deaths"]
binomial.mod <- glarma(y, X.1,
phiLags = c(12),
thetaLags = c(12),
type = "Poi", method = "FS",
residuals = "Pearson", maxit = 100, grad = 1e-6)
binomial.mod <- glarma(y.1, X.1,
phiLags = c(12),
thetaLags = c(12),
type = "Poi", method = "FS",
residuals = "Pearson", maxit = 100, grad = 1e-6)
type(X.1)
type(x)
type(X)
type(y)
type(y.1)
infer_type(y)
y.1[1]
infer_type(y.1[1])
infer_type(y[1])
library(zoo)
library(forecast) # tsdisplay, stl
library(arrow) # parquet reading
library(tseries) # adf.test
library(lubridate)
indicator <- "ep_total"
buffer <- 25
# load data
df1 <- read_parquet("/Users/alison/Documents/RAPID/correlation-analysis/data_results/nf/full_timeseries/wrz_1/NF1.parquet")
df2 <- read_parquet("/Users/alison/Documents/RAPID/correlation-analysis/data_results/nf/full_timeseries/wrz_1/NF2.parquet")
df3 <- read_parquet("/Users/alison/Documents/RAPID/correlation-analysis/data_results/nf/full_timeseries/wrz_1/NF3.parquet")
# process dataframe: concatenate the ensembles to help fit
format.date <- function(date_string) {
date <- as.Date(date_string)
year <- as.integer(format(date, "%Y"))
month <- as.integer(format(date, "%m"))
day <- as.integer(format(date, "%d"))
return(c(year, month, day))
}
make_ts <- function(df,indicator, buffer, delta=c(0, 0, 0)){
# process df
df <- df[(df$buffer==buffer),]
df$date <- make_date(year=df$Year, month=df$Month)
all.dates <- seq.Date(min(df$date), max(df$date), "month")
df <- merge(x=data.frame(date=all.dates), y=df, all.x=TRUE)
# get key dates
start.date <- format.date(df[1, "date"]) + delta
end.date <- format.date(df[dim(df)[1], "date"]) + delta
df$date <- df$date + years(delta[1]) + months(delta[2]) + days(delta[3])
# fill in any NaNs
zoo.values <- zoo(df[, c(indicator, "LoS")], df$date)
approx.values <- na.approx(zoo.values)
return(list(ts=approx.values, start=start.date, end=end.date))
}
concat_ts <- function(dfs, indicator, buffer){
delta = c(0, 0, 0)
res <- make_ts(dfs[[1]],indicator, buffer)
start <- res$start
end <- res$end
ts <- res$ts
delta <- end - start + c(0, 0, 1)
for(df in dfs[2:length(dfs)]){
res <- make_ts(df, indicator, buffer, delta)
ts <- rbind(ts, res$ts)
end <- res$end
delta <- end - start + c(0, 0, 1)
}
ts <- ts(ts, start=start, end=end, frequency=12)
return(list(ts=ts, start=start, end=end))
}
res <- concat_ts(dfs=list(df1, df2, df3), indicator=indicator, buffer=buffer)
ts <- res$ts
tsdisplay(ts[,indicator]) # lags don't die out but oscillate => trend/seasonality
tsdisplay(ts[,'LoS']) # lags die out so ok stationary
adf.test(ts[,indicator]) # p-value < 0.01, alternative hypothesis: stationary
adf.test(ts[,"LoS"]) # p-value < 0.01, alternative hypothesis: stationary, only for residuals
# cumulative periodograms => trend and periodicity
par(mfrow=c(2, 2))
cpgram(ts[,"LoS"])
cpgram(diff(ts[,"LoS"]))
cpgram(ts[,indicator])
cpgram(diff(diff(ts[,indicator], 12)))
diffs <- function(x, diffs=c(1), start=res$start, end=res$end){
for(d in diffs){
x <- diff(x, d)
}
return(x)
}
d1 <- diffs(ts[,indicator], c(1, 12))
d2 <- diffs(ts[,"LoS"], c(1))
ts.d <- ts[1:length(d1),]
ts.d[, indicator] <- d1
ts.d[, "LoS"] <- d2[1:length(d1)]
ts.d <- ts(ts.d, start=res$start, end=res$end, frequency=12)
# ACDF and PACFs
par(mfrow=c(2,2))
acf(ts.d[,indicator])
acf(ts.d[,"LoS"])
pacf(ts.d[,indicator])
pacf(ts.d[,"LoS"])
# What do these suggest? That both are moving average processes.
par(mfrow=c(1, 1))
plot(decompose(x))
plot(decompose(ts[,indicator]))
decompose(ts[,indicator])$seasonal
y.1 <- as.integer(ts[,"LoS"])
plot(decompose(ts.d[,indicator]))
decompose(ts[,indicator])$seasonal
y.1 <- as.integer(ts[,"LoS"])
X.1 <- as.numeric(ts.d[,indicator])
X.1 <- cbind(intersect=rep(1, length(X.1)), variable=X.1)
binomial.mod <- glarma(y.1, X.1,
phiLags = c(12),
thetaLags = c(12),
type = "Poi", method = "FS",
residuals = "Pearson", maxit = 100, grad = 1e-6)
y.1[1:5]
X.1[1:5,]
binomial.mod <- glarma(y.1[1:5], X.1[1:5,],
phiLags = c(12),
thetaLags = c(12),
type = "Poi", method = "FS",
residuals = "Pearson", maxit = 100, grad = 1e-6)
binomial.mod <- glarma(y.1[1:5], X.1[1:5,])
binomial.mod <- glarma(y.1 X.1)
binomial.mod <- glarma(y.1, X.1)
summary(glarmamod)
summary(binomial.mod)
binomial.mod <- glarma(y.1, X.1, family=poisson())
binomial.mod <- glarma(y.1, X.1, type=poisson())
binomial.mod <- glarma(y.1, X.1, type="Poi")
summary(binomial.mod)
par(mfrow=c(2,2))
acf(ts.d[,indicator])
acf(ts.d[,"LoS"])
pacf(ts.d[,indicator])
pacf(ts.d[,"LoS"])
d1 <- diffs(ts[,indicator], c(1, 1, 12))
d2 <- diffs(ts[,"LoS"], c(1))
ts.d <- ts[1:length(d1),]
ts.d[, indicator] <- d1
ts.d[, "LoS"] <- d2[1:length(d1)]
ts.d <- ts(ts.d, start=res$start, end=res$end, frequency=12)
# ACDF and PACFs
par(mfrow=c(2,2))
acf(ts.d[,indicator])
acf(ts.d[,"LoS"])
pacf(ts.d[,indicator])
pacf(ts.d[,"LoS"])
d1 <- diffs(ts[,indicator], c(1, 12))
d2 <- diffs(ts[,"LoS"], c(1))
ts.d <- ts[1:length(d1),]
ts.d[, indicator] <- d1
ts.d[, "LoS"] <- d2[1:length(d1)]
ts.d <- ts(ts.d, start=res$start, end=res$end, frequency=12)
# ACDF and PACFs
par(mfrow=c(2,2))
acf(ts.d[,indicator])
acf(ts.d[,"LoS"])
pacf(ts.d[,indicator])
pacf(ts.d[,"LoS"])
par(mfrow=c(1, 1))
plot(decompose(ts.d[,indicator]))
decompose(ts[,indicator])$seasonal
y.1 <- as.integer(ts[,"LoS"])
X.1 <- as.numeric(ts.d[,indicator])
X.1 <- cbind(intersect=rep(1, length(X.1)), variable=X.1)
binomial.mod <- glarma(y.1, X.1, type="Poi", phiLags=c(12), thetaLags=c(12))
binomial.mod <- glarma(y.1, X.1, type="Poi", phiLags=c(1), thetaLags=c(1))
binomial.mod <- glarma(y.1, X.1, type="Poi")
summary(binomial.mod)
binomial.mod <- glarma(y.1, X.1, type="Poi", thetaLags=c(1))
binomial.mod <- glarma(y.1, X.1, type="Poi", thetaLags=c(12))
binomial.mod <- glarma(y.1, X.1, type="Poi", phiLags=c(1), thetaLags=c(12))
binomial.mod <- glarma(y.1, X.1, type="Poi", phiLags=c(12), thetaLags=c(12))
binomial.mod <- glarma(y.1, X.1, type="Poi", phiLags=c(2), thetaLags=c(12))
binomial.mod <- glarma(y.1, X.1, type="Poi" thetaLags=c(12))
binomial.mod <- glarma(y.1, X.1, type="Poi", thetaLags=c(12))
summary(binomial.mod)
binomial.mod <- glarma(y.1, X.1, type="Poi", thetaLags=c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12))
# ACDF and PACFs
par(mfrow=c(2,2))
acf(ts.d[,indicator])
acf(ts.d[,"LoS"])
pacf(ts.d[,indicator])
pacf(ts.d[,"LoS"])
binomial.mod <- glarma(y.1, X.1, type="Poi", thetaLags=c(1, 2, 11, 12, 13))
binomial.mod <- glarma(y.1, X.1, type="Poi", thetaLags=c(1, 2, 12))
binomial.mod <- glarma(y.1, X.1, type="Poi", thetaLags=c(1, 12))
binomial.mod <- glarma(y.1, X.1, type="Poi", thetaLags=c(1, 12))
binomial.mod <- glarma(y.1, X.1, type="Poi", thetaLags=c(1, 12))
binomial.mod <- glarma(y.1, X.1, type="Poi", thetaLags=c(1)
binomial.mod <- glarma(y.1, X.1, type="Poi", thetaLags=c(1))
binomial.mod <- glarma(y.1, X.1, type="Poi", thetaLags=c(1))
binomial.mod <- glarma(y.1, X.1, type="Poi", thetaLags=c(12))
binomial.mod <- glarma(y.1, X.1, type="NegBin", thetaLags=c(12))
summary(binomial.mod)
binomial.mod <- glarma(y.1, X.1, type="Poi", thetaLags=c(12))
summary(binomial.mod)
binomial.mod <- glarma(y.1, X.1, type="Poi", thetaLags=c(1, 2, 12), maxit=100)
binomial.mod <- glarma(y.1, X.1, type="Poi", thetaLags=c(1), maxit=100)
binomial.mod <- glarma(y.1, X.1, type="Poi", thetaLags=c(12), maxit=100)
summary(binomial.mod)
plot(ts[,"LoS"])
par(mfrow=c(2, 1))
plot(ts[,"LoS"])
plot(ts.d[,indicator])
binomial.mod <- glarma(y.1, X.1, type="Poi", thetaLags=c(12), maxit=30)
par(mfrow=c(2,2))
acf(ts.d[,indicator])
acf(ts[,"LoS"])
pacf(ts.d[,indicator])
pacf(ts[,"LoS"])
ts.d <- ts[1:length(d1),]
ts.d[, indicator] <- d1
ts.d[, "LoS"] <- ts[1:length(d1), "LoS"]
ts.d <- ts(ts.d, start=res$start, end=res$end, frequency=12)
par(mfrow=c(2,2))
acf(ts.d[,indicator])
acf(ts.d[,"LoS"])
pacf(ts.d[,indicator])
pacf(ts.d[,"LoS"])
binomial.mod <- glarma(y.1, X.1, type="Poi", phiLags=c(12),thetaLags=c(12), maxit=30)
binomial.mod <- glarma(y.1, X.1, type="Poi", phiLags=c(12), thetaLags=c(12), maxit=30)
binomial.mod <- glarma(y.1, X.1, type="Poi", thetaLags=c(12), maxit=30)
binomial.mod <- glarma(y.1, X.1, type="Poi", phiLags=c(1), thetaLags=c(12), maxit=30)
binomial.mod <- glarma(y.1, X.1, type="Poi", phiLags=c(8), thetaLags=c(2, 12), maxit=30)
binomial.mod <- glarma(y.1, X.1, type="Poi", phiLags=c(8), thetaLags=c(2, 12), maxit=1000)
binomial.mod <- glarma(y.1, X.1, type="Poi", phiLags=c(8), thetaLags=c(2, 12), maxit=1000)
?glarma
binomial.mod <- glarma(y.1, X.1, type="Poi", phiLags=c(8), thetaLags=c(2, 12), method="NR")
binomial.mod <- glarma(y.1, X.1, type="Poi", thetaLags=c(2, 12), method="NR")
binomial.mod <- glarma(y.1, X.1, type="Poi", thetaLags=c(1, 12), method="NR")
